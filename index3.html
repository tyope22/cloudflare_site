<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Image Optimizer</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load React and Babel -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        /* Optional: Sets Inter font globally */
        body { font-family: 'Inter', sans-serif; }
    </style>
</head>
<body>

    <!-- Target container for the React app -->
    <div id="root"></div>

    <script type="text/babel">
const { useState, useCallback, useRef, useMemo } = React;

// Main App Component
const App = () => {
    // --- State Management ---
    const [originalFile, setOriginalFile] = useState(null);
    const [originalImage, setOriginalImage] = useState(null);
    const [status, setStatus] = useState('Ready: Upload an image to start.');
    const [targetFormat, setTargetFormat] = useState('webp'); 
    const [quality, setQuality] = useState(85); 
    
    // Resolution Mode States
    const [resolutionMode, setResolutionMode] = useState('scale'); // 'scale' or 'crop'
    const [maxWidth, setMaxWidth] = useState(1920); // Max width for scaling
    const [maxHeight, setMaxHeight] = useState(1920); // Max height for scaling
    const [cropWidth, setCropWidth] = useState(900); // Fixed width for cropping
    const [cropHeight, setCropHeight] = useState(500); // Fixed height for cropping
    const [cropOrigin, setCropOrigin] = useState('center'); // 'top-left', 'center', etc.

    const [isProcessing, setIsProcessing] = useState(false);

    // Ref for the hidden canvas used for image manipulation
    const canvasRef = useRef(null);
    
    // --- Utility Function: Get Crop Coordinates ---
    const getCropCoords = useCallback((imgWidth, imgHeight, outWidth, outHeight, origin) => {
        const cropX = 0; // Source x-coordinate (on original image)
        const cropY = 0; // Source y-coordinate (on original image)
        const cropW = outWidth; // Source width to crop
        const cropH = outHeight; // Source height to crop
        
        // Find the dimensions of the area we need to crop from the original image
        let srcW = outWidth;
        let srcH = outHeight;
        let srcX = 0;
        let srcY = 0;

        // Calculate aspect ratios
        const imgRatio = imgWidth / imgHeight;
        const cropRatio = outWidth / outHeight;

        if (imgRatio > cropRatio) {
            // Image is wider than target. Crop height is limited by imgHeight.
            srcH = imgHeight;
            srcW = imgHeight * cropRatio;
        } else if (imgRatio < cropRatio) {
            // Image is taller than target. Crop width is limited by imgWidth.
            srcW = imgWidth;
            srcH = imgWidth / cropRatio;
        } else {
            // Ratios match, just use full image size
            srcW = imgWidth;
            srcH = imgHeight;
        }

        // --- Calculate Starting Crop Position (X and Y) ---
        
        // Horizontal Placement
        if (origin.includes('right')) {
            srcX = imgWidth - srcW;
        } else if (origin.includes('center')) {
            srcX = (imgWidth - srcW) / 2;
        }
        // 'left' is default (srcX = 0)

        // Vertical Placement
        if (origin.includes('bottom')) {
            srcY = imgHeight - srcH;
        } else if (origin.includes('center')) {
            srcY = (imgHeight - srcH) / 2;
        }
        // 'top' is default (srcY = 0)


        // The output dimensions are fixed to outWidth and outHeight
        return {
            sx: srcX, // Source X
            sy: srcY, // Source Y
            sw: srcW, // Source Width
            sh: srcH, // Source Height
            dx: 0,    // Destination X (always 0)
            dy: 0,    // Destination Y (always 0)
            dw: outWidth, // Destination Width
            dh: outHeight, // Destination Height
        };
    }, []);
    
    // --- File Handling and Image Loading ---

    const handleFileChange = (event) => {
        const file = event.target.files[0];
        if (!file) return;

        setOriginalFile(file);
        setOriginalImage(null);
        setStatus('Loading image...');

        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                setOriginalImage(img);
                setStatus(`Image loaded: ${file.name} (${img.width}x${img.height})`);
                // Reset dimensions based on image size to prevent excessive resizing
                setMaxWidth(img.width);
                setMaxHeight(img.height);
                setCropWidth(Math.min(900, img.width));
                setCropHeight(Math.min(500, img.height));
            };
            img.onerror = () => {
                setStatus('Error loading image.');
                setOriginalFile(null);
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    };

    // --- Core Conversion and Optimization Logic ---

    const processAndDownload = useCallback(() => {
        if (!originalImage) {
            setStatus('Please load an image first.');
            return;
        }
        
        if (resolutionMode === 'crop' && (cropWidth <= 0 || cropHeight <= 0)) {
            setStatus('Crop dimensions must be greater than zero.');
            return;
        }

        setIsProcessing(true);
        setStatus('Processing and optimizing...');

        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const imgW = originalImage.width;
        const imgH = originalImage.height;

        // 1. Calculate and Draw
        if (resolutionMode === 'scale') {
            let { width: w, height: h } = originalImage;
            const targetMaxWidth = parseInt(maxWidth);
            const targetMaxHeight = parseInt(maxHeight);

            // Aspect Ratio Preserved Scaling
            const ratio = Math.min(targetMaxWidth / w, targetMaxHeight / h);
            
            if (ratio < 1) { 
                w = Math.floor(w * ratio);
                h = Math.floor(h * ratio);
            }

            canvas.width = w;
            canvas.height = h;
            ctx.clearRect(0, 0, w, h); 
            ctx.drawImage(originalImage, 0, 0, w, h); // Draw full image, scaled
            
            setStatus(`Successfully scaled and converted to ${targetFormat.toUpperCase()} (${w}x${h}).`);

        } else if (resolutionMode === 'crop') {
            const outW = parseInt(cropWidth);
            const outH = parseInt(cropHeight);

            // Cropping and Resizing to Fixed Dimensions
            const coords = getCropCoords(imgW, imgH, outW, outH, cropOrigin);
            
            canvas.width = outW;
            canvas.height = outH;
            ctx.clearRect(0, 0, outW, outH);

            // Arguments for drawImage: (image, sx, sy, sw, sh, dx, dy, dw, dh)
            ctx.drawImage(
                originalImage, 
                coords.sx, coords.sy, coords.sw, coords.sh,
                coords.dx, coords.dy, coords.dw, coords.dh
            );
            
            setStatus(`Successfully cropped and converted to ${targetFormat.toUpperCase()} (${outW}x${outH}).`);
        }

        // 2. Prepare MimeType and Quality (Size/Compression Optimization)
        let mimeType, defaultQuality;
        let fileExtension = targetFormat;
        
        switch (targetFormat) {
            case 'webp':
                mimeType = 'image/webp';
                defaultQuality = quality / 100; 
                break;
            case 'jpeg':
                mimeType = 'image/jpeg';
                defaultQuality = quality / 100; 
                fileExtension = 'jpg';
                break;
            case 'png':
            default:
                mimeType = 'image/png';
                defaultQuality = 1.0; 
                fileExtension = 'png';
                break;
        }
        
        // --- 3. Get the result (DataURL) and download ---
        const dataUrl = canvas.toDataURL(mimeType, defaultQuality);
        const blob = dataURLToBlob(dataUrl);

        // Create download link
        const link = document.createElement('a');
        const baseName = originalFile.name.substring(0, originalFile.name.lastIndexOf('.')) || originalFile.name;
        link.download = `${baseName}-optimized.${fileExtension}`;
        link.href = URL.createObjectURL(blob);
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        URL.revokeObjectURL(link.href);
        
        setIsProcessing(false);

    }, [originalImage, targetFormat, quality, resolutionMode, maxWidth, maxHeight, cropWidth, cropHeight, cropOrigin, originalFile, getCropCoords]);

    // Helper function to convert DataURL to Blob for downloading
    const dataURLToBlob = (dataUrl) => {
        const parts = dataUrl.split(';base64,');
        if (parts.length < 2) throw new Error("Invalid DataURL");

        const contentType = parts[0].split(':')[1];
        const raw = window.atob(parts[1]);
        const rawLength = raw.length;
        const uInt8Array = new Uint8Array(rawLength);
        
        for (let i = 0; i < rawLength; ++i) {
            uInt8Array[i] = raw.charCodeAt(i);
        }
        return new Blob([uInt8Array], { type: contentType });
    };

    // --- UI Rendering ---

    const isLossyFormat = targetFormat === 'webp' || targetFormat === 'jpeg';
    const isReady = originalImage && !isProcessing;
    
    // Component for Input/Display
    const ImageDisplay = () => (
        <div className="flex flex-col items-center justify-center p-4 bg-gray-100 border border-dashed border-gray-300 rounded-xl min-h-[12rem] w-full">
            {originalImage ? (
                <img 
                    src={originalImage.src} 
                    alt="Original Upload" 
                    className="max-h-48 rounded-lg shadow-md mb-3" 
                    style={{ maxWidth: '100%', maxHeight: '10rem' }}
                />
            ) : (
                <svg className="w-12 h-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
            )}
            <p className="text-sm font-medium text-gray-600 mt-2 text-center">
                {originalImage ? `${originalImage.width}x${originalImage.height} | ${originalFile.type}` : 'Upload an image above'}
            </p>
        </div>
    );

    // Component for Controls
    const ControlWindow = ({ title, children }) => (
        <div className="bg-white p-6 rounded-xl shadow-lg border border-gray-100">
            <h3 className="text-xl font-semibold text-gray-800 mb-4 border-b pb-2">{title}</h3>
            <div className="space-y-4">
                {children}
            </div>
        </div>
    );
    
    // Component for Crop Origin Selection
    const CropOriginSelector = () => {
        const origins = ['top-left', 'top-center', 'top-right', 'center-left', 'center', 'center-right', 'bottom-left', 'bottom-center', 'bottom-right'];
        
        return (
            <div className="grid grid-cols-3 gap-2 p-2 bg-gray-100 rounded-lg">
                {origins.map(origin => (
                    <button
                        key={origin}
                        onClick={() => setCropOrigin(origin)}
                        className={`p-2 rounded-md text-xs font-medium transition duration-150 border ${
                            cropOrigin === origin 
                                ? 'bg-indigo-600 text-white shadow-md border-indigo-700' 
                                : 'bg-white text-gray-700 hover:bg-gray-50 border-gray-300'
                        }`}
                        title={`Crop anchored to ${origin.replace('-', ' ').toUpperCase()}`}
                    >
                        {/* Use simple direction label for buttons */}
                        {origin.split('-').map(s => s[0].toUpperCase()).join('')}
                    </button>
                ))}
            </div>
        );
    };

    // Render the main application structure
    return (
        <div className="p-4 sm:p-8 bg-gray-50 min-h-screen flex justify-center w-full">
            <div className="w-full max-w-5xl">
                <h1 className="text-4xl font-extrabold text-indigo-700 mb-2">Advanced Image Optimization Tool</h1>
                <p className="text-gray-600 mb-8">Perform various format conversions and apply both resolution (scaling/cropping) and compression optimization in-browser.</p>

                {/* File Input & Target Format */}
                <div className="bg-white p-6 rounded-xl shadow-xl mb-6">
                    <label htmlFor="fileInput" className="block text-lg font-medium text-gray-800 mb-2">1. Upload Source Image</label>
                    <input 
                        type="file" 
                        id="fileInput" 
                        accept="image/jpeg, image/png, image/webp" 
                        onChange={handleFileChange}
                        className="block w-full text-sm text-gray-900 border border-gray-300 rounded-lg cursor-pointer bg-gray-50 p-2.5 hover:bg-gray-100"
                    />

                    <label className="block text-lg font-medium text-gray-800 mt-6 mb-2">2. Select Target Format</label>
                    <div className="flex space-x-4">
                        {['webp', 'jpeg', 'png'].map((format) => (
                            <button
                                key={format}
                                onClick={() => setTargetFormat(format)}
                                className={`px-4 py-2 rounded-lg font-semibold transition duration-150 ${
                                    targetFormat === format 
                                        ? 'bg-indigo-600 text-white shadow-md' 
                                        : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                }`}
                            >
                                {format.toUpperCase()}
                            </button>
                        ))}
                    </div>
                </div>

                <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
                    {/* Image Display Window */}
                    <div className="lg:col-span-1">
                        <ImageDisplay />
                    </div>

                    {/* Resolution Optimization Window */}
                    <div className="lg:col-span-1">
                        <ControlWindow title="3. Resolution Optimization">
                            <div className="flex space-x-4 mb-4">
                                <button
                                    onClick={() => setResolutionMode('scale')}
                                    className={`px-4 py-2 rounded-lg font-semibold transition duration-150 w-1/2 ${
                                        resolutionMode === 'scale' 
                                            ? 'bg-purple-600 text-white shadow-md' 
                                            : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                    }`}
                                >
                                    Scale (Preserve Aspect)
                                </button>
                                <button
                                    onClick={() => setResolutionMode('crop')}
                                    className={`px-4 py-2 rounded-lg font-semibold transition duration-150 w-1/2 ${
                                        resolutionMode === 'crop' 
                                            ? 'bg-purple-600 text-white shadow-md' 
                                            : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                    }`}
                                >
                                    Crop (Fixed Aspect)
                                </button>
                            </div>

                            {resolutionMode === 'scale' ? (
                                <div className="space-y-4">
                                    <label className="block text-sm font-medium text-gray-700">Max Width: <span className="font-bold text-purple-600">{maxWidth}</span> px</label>
                                    <input 
                                        type="range" 
                                        min="100" 
                                        max={originalImage ? originalImage.width : 2000} 
                                        value={maxWidth} 
                                        step="10" 
                                        onChange={(e) => setMaxWidth(e.target.value)}
                                        className="w-full h-2 bg-purple-100 rounded-lg appearance-none cursor-pointer"
                                    />
                                    
                                    <label className="block text-sm font-medium text-gray-700 mt-4">Max Height: <span className="font-bold text-purple-600">{maxHeight}</span> px</label>
                                    <input 
                                        type="range" 
                                        min="100" 
                                        max={originalImage ? originalImage.height : 2000} 
                                        value={maxHeight} 
                                        step="10" 
                                        onChange={(e) => setMaxHeight(e.target.value)}
                                        className="w-full h-2 bg-purple-100 rounded-lg appearance-none cursor-pointer"
                                    />
                                    <p className="text-xs text-gray-500 mt-2">The image will be scaled down to fit within these limits.</p>
                                </div>
                            ) : (
                                <div className="space-y-4">
                                    <div className="flex space-x-4">
                                        <div className="w-1/2">
                                            <label htmlFor="cropWidth" className="block text-sm font-medium text-gray-700">Output Width (px)</label>
                                            <input
                                                type="number"
                                                id="cropWidth"
                                                value={cropWidth}
                                                onChange={(e) => setCropWidth(e.target.value)}
                                                min="1"
                                                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-purple-500 focus:ring-purple-500 p-2 border"
                                            />
                                        </div>
                                        <div className="w-1/2">
                                            <label htmlFor="cropHeight" className="block text-sm font-medium text-gray-700">Output Height (px)</label>
                                            <input
                                                type="number"
                                                id="cropHeight"
                                                value={cropHeight}
                                                onChange={(e) => setCropHeight(e.target.value)}
                                                min="1"
                                                className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-purple-500 focus:ring-purple-500 p-2 border"
                                            />
                                        </div>
                                    </div>
                                    <h4 className="text-sm font-medium text-gray-700 pt-2">Crop Origin:</h4>
                                    <CropOriginSelector />
                                    <p className="text-xs text-gray-500 mt-2">The image will be centered on this point and cropped to the exact dimensions.</p>
                                </div>
                            )}
                        </ControlWindow>
                    </div>

                    {/* Size (Compression) Optimization Window */}
                    <div className="lg:col-span-1">
                        <ControlWindow title="4. Size (Compression) Optimization">
                            <label className={`block text-sm font-medium ${isLossyFormat ? 'text-gray-700' : 'text-gray-400'}`}>
                                Compression Quality: <span className="font-bold text-indigo-600">{quality}</span>%
                            </label>
                            <input 
                                type="range" 
                                min="10" 
                                max="100" 
                                value={quality} 
                                onChange={(e) => setQuality(e.target.value)}
                                disabled={!isLossyFormat}
                                className={`w-full h-2 rounded-lg appearance-none cursor-pointer ${isLossyFormat ? 'bg-indigo-100' : 'bg-gray-200'}`}
                            />
                            <p className="text-xs text-gray-500 mt-2">
                                {isLossyFormat
                                    ? `Applies to ${targetFormat.toUpperCase()} (Lossy). Lower quality = smaller file size.`
                                    : 'PNG is a lossless format, so quality controls have minimal effect.'
                                }
                            </p>
                        </ControlWindow>
                    </div>
                </div>

                {/* Action & Status */}
                <div className="flex flex-col sm:flex-row justify-between items-center bg-white p-6 rounded-xl shadow-xl">
                    <div className="w-full sm:w-1/2 text-center sm:text-left mb-4 sm:mb-0">
                        <p className={`font-semibold ${isProcessing ? 'text-yellow-600' : 'text-gray-700'}`}>{status}</p>
                    </div>
                    <button 
                        onClick={processAndDownload}
                        disabled={!isReady || isProcessing}
                        className="w-full sm:w-auto bg-green-600 text-white p-3 rounded-xl font-semibold shadow-lg hover:bg-green-700 transition duration-150 ease-in-out disabled:opacity-50"
                    >
                        {isProcessing ? 'Processing...' : `Convert & Download ${targetFormat.toUpperCase()}`}
                    </button>
                </div>
            </div>

            {/* Hidden Canvas element */}
            <canvas ref={canvasRef} style={{ display: 'none' }}></canvas>
        </div>
    );
};

// Render the App component into the root DOM element
const container = document.getElementById('root');
const root = ReactDOM.createRoot(container);
root.render(<App />);
    </script>
</body>
</html>
